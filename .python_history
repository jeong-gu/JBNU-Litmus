class ProblemAdmin(NoBatchDeleteMixin, VersionAdmin):
    fieldsets = (
        (None, {
            'fields': (
                'code', 'name', 'is_public', 'date', 'authors', 'testers',
                'description',
            ),
        }),
        (_('Taxonomy'), {'fields': ('types', 'group')}),
        (_('Points'), {'fields': ('points',)}),
        (_('Limits'), {'fields': ('time_limit', 'memory_limit')}),
        (_('Language'), {'fields': ('allowed_languages',)}),
    )
    list_display = ['code', 'name', 'show_authors', 'points', 'is_public', 'show_public']
    ordering = ['code']
    search_fields = ('code', 'name', 'authors__user__username', 'curators__user__username')
    inlines = []
    list_max_show_all = 1000
    actions_on_top = True
    actions_on_bottom = True
    list_filter = ('is_public', ProblemCreatorListFilter)
    form = ProblemForm
    date_hierarchy = 'date'
    def get_actions(self, request):
        actions = super(ProblemAdmin, self).get_actions(request)
        if request.user.has_perm('judge.change_public_visibility'):
            func, name, desc = self.get_action('make_public')
            actions[name] = (func, name, desc)
            func, name, desc = self.get_action('make_private')
            actions[name] = (func, name, desc)
        func, name, desc = self.get_action('update_publish_date')
        actions[name] = (func, name, desc)
        return actions
    def get_readonly_fields(self, request, obj=None):
        fields = self.readonly_fields
        if not request.user.has_perm('judge.change_public_visibility'):
            fields += ('is_public',)
        if not request.user.has_perm('judge.change_manually_managed'):
            fields += ('is_manually_managed',)
        if not request.user.has_perm('judge.problem_full_markup'):
            fields += ('is_full_markup',)
            if obj and obj.is_full_markup:
                fields += ('description',)
        return fields
    def show_authors(self, obj):
        return ', '.join(map(attrgetter('user.username'), obj.authors.all()))
    show_authors.short_description = _('Authors')
    def show_public(self, obj):
        return format_html('<a href="{1}">{0}</a>', gettext('View on site'), obj.get_absolute_url())
    show_public.short_description = ''
    def _rescore(self, request, problem_id):
        from judge.tasks import rescore_problem
        transaction.on_commit(rescore_problem.s(problem_id).delay)
    def update_publish_date(self, request, queryset):
        count = queryset.update(date=timezone.now())
        self.message_user(request, ngettext("%d problem's publish date successfully updated.",
                                            "%d problems' publish date successfully updated.",
                                            count) % count)
    update_publish_date.short_description = _('Set publish date to now')
    def make_public(self, request, queryset):
        count = queryset.update(is_public=True)
        for problem_id in queryset.values_list('id', flat=True):
            self._rescore(request, problem_id)
        self.message_user(request, ngettext('%d problem successfully marked as public.',
                                            '%d problems successfully marked as public.',
                                            count) % count)
    make_public.short_description = _('Mark problems as public')
    def make_private(self, request, queryset):
        count = queryset.update(is_public=False)
        for problem_id in queryset.values_list('id', flat=True):
            self._rescore(request, problem_id)
        self.message_user(request, ngettext('%d problem successfully marked as private.',
                                            '%d problems successfully marked as private.',
                                            count) % count)
    make_private.short_description = _('Mark problems as private')
    def get_queryset(self, request):
        return Problem.get_editable_problems(request.user).prefetch_related('authors__user').distinct()
    def has_change_permission(self, request, obj=None):
        if obj is None:
            return request.user.has_perm('judge.edit_own_problem')
        return obj.is_editable_by(request.user)
    def formfield_for_manytomany(self, db_field, request=None, **kwargs):
        if db_field.name == 'allowed_languages':
            kwargs['widget'] = CheckboxSelectMultipleWithSelectAll()
        return super(ProblemAdmin, self).formfield_for_manytomany(db_field, request, **kwargs)
    def get_form(self, request, *args, **kwargs):
        form = super(ProblemAdmin, self).get_form(request,*args, **kwargs)
        form.base_fields['authors'].initial = request.user.username
        return form
    def save_model(self, request, obj, form, change):
        form.cleaned_data['authors'] = Profile.objects.filter(user__username=request.user.username)
        # self.form.fields['authors'].widget = forms.TextInput(attrs={'value': form.cleaned_data['authors']})
        if form.changed_data and 'organizations' in form.changed_data:
            obj.is_organization_private = bool(form.cleaned_data['organizations'])
        super(ProblemAdmin, self).save_model(request, obj, form, change)
        if (
            form.changed_data and
            any(f in form.changed_data for f in ('is_public', 'organizations', 'points', 'partial'))
        ):
            self._rescore(request, obj.id)
    def construct_change_message(self, request, form, *args, **kwargs):
        if form.cleaned_data.get('change_message'):
            return form.cleaned_data['change_message']
        return super(ProblemAdmin, self).construct_change_message(request, form, *args, **kwargs)
exit()
import pickle
with open('/home/ubuntu/log.ksl', 'rb') as f:
data = pickle.load(f)
    data = pickle.load(f)
with open('/home/ubuntu/log.ksl', 'rb') as f:
    data = pickle.load(f)
print(data)
data
    data = pickle.load(f); print(data)
with open('/home/ubuntu/log.ksl', 'rb') as f:
    data = pickle.load(f); print(data)
clear
exit()
